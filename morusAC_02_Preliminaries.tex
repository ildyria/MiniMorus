\section{Preliminaries}
\label{Sec/Preliminaries}

\subsection{Specification of MORUS}
\label{subsec/Spec}
MORUS \cite{MORUS} is a family of authenticated ciphers with two internal state sizes: 640 and 1280 bits. Each member is called \cipher{MORUS640} and \cipher{MORUS1280}, respectively. In the recommended parameters, \cipher{MORUS640} supports 128-bit keys and \cipher{MORUS1280} supports both 128-bit and 256-bit keys. The tag size is 128 bits or shorter. The designers strongly recommend using a 128-bit tag.

The state of MORUS is divided into five registers. Let $q$ be the register size, where $q = 128$ for \cipher{MORUS640} and $q=256$ for \cipher{MORUS1280}. Let $S_i, i \in\{0,1,2,3,4\}$ be a register. Then, the state is represented as $S_0\|S_1\|S_2\|S_3\|S_4$. The state is first initialized by a key and nonce, and then updated by associated data blocks and message blocks step by step. Hence, we use a superscript to denote the step number of the state as $S^t_0\|S^t_1\|S^t_2\|S^t_3\|S^t_4$, where $t$ is $-16$ before the initialization and $t=0$ after the initialization.

The computation of MORUS consists of four parts; initialization, associated data process, encryption, and finalization. All parts share the core design called the {\tt StepUpdate} function. %Hereafter we explain {\tt StepUpdate}.

\subsubsection{Step Update Function.}
{\tt StepUpdate} takes as input the internal state $S^t = S^t_0\|S^t_1\|S^t_2\|S^t_3\|S^t_4$ and additional register-wise value $m^t$. $m^t$ is supposed to be associated data block or message block. $m^t$ can sometimes be 0 or constant when the additional input is unnecessary.

{\tt StepUpdate} is composed of 5 rounds with similar operations to update
the state $S^t$, in which the additional input $m^t$ is used in rounds 2 to 5, but not in round 1. Each round uses the word-wise left circular shift, which divides a $q$-bit register value into 4 words of $q/4$ bits, and performs left circular shift operation for every $q/4$-bit word. Throughout the paper, we denote the word size by $w$, i.e. $w=32$ for \cipher{MORUS640} and $w=64$ for \cipher{MORUS1280}. The word-wise circular shift constants $b_i$ in round $i$ are defined in Table~\ref{Tbl:rcon}. Besides, the left rotation of a whole $q$-bit register is used. The register-wise circular shift constants are also listed in Table~\ref{Tbl:rcon}.
\begin{table}[!htb]
\centering
\caption{Left Circular-Shift Constants of MORUS} \label{Tbl:rcon}
\begin{tabular}{c||ccccc|ccccc} \hline
& \multicolumn{5}{c|}{word-wise circular shift} & \multicolumn{5}{c}{register-wise circular shift} \\
                  & \makebox[2em]{$b_0$} & \makebox[2em]{$b_1$} & \makebox[2em]{$b_2$} & \makebox[2em]{$b_3$} & \makebox[2em]{$b_4$} & \makebox[2em]{$b'_0$} & \makebox[2em]{$b'_1$} & \makebox[2em]{$b'_2$} & \makebox[2em]{$b'_3$} & \makebox[2em]{$b'_4$} \\ \hline
\cipher{MORUS640} &  5 & 31 &  7 & 22 & 13 & 32 &  64 &  96 &  64 & 32 \\
\cipher{MORUS1280}& 13 & 46 & 38 &  7 &  4 & 64 & 128 & 192 & 128 & 64 \\ \hline
\end{tabular}
\end{table}
We denote those register-wise and word-wise left circular shift by $x \lll y$ and $x \lll_w y$, respectively. (Those are denoted by \texttt{<<<} and \texttt{Rotl\_xxx\_yy} respectively in the \cipher{MORUS} design document.)

Let `$\cdot$' denote the bit-wise AND operation. $S^{t+1} \leftarrow {\tt StateUpdate}(S^t,m^t)$ is defined as follows.
\begin{align*}
\textrm{Round 1:} &&
S^{t+1}_0 &\leftarrow ( S^t_0 \oplus (S^t_1 \cdot S^t_2) \oplus S^t_3 ) \lll_w b_0 &
S^t_3 \leftarrow S^t_3 \lll b'_0.\\
\textrm{Round 2:} &&
S^{t+1}_1 &\leftarrow ( S^t_1 \oplus (S^t_2 \cdot S^t_3) \oplus S^t_4 \oplus m_i ) \lll_w b_1 &
S^t_4 \leftarrow S^t_4 \lll b'_1.\\
\textrm{Round 3:} &&
S^{t+1}_2 &\leftarrow ( S^t_2 \oplus (S^t_3 \cdot S^t_4) \oplus S^t_0 \oplus m_i ) \lll_w b_2 &
S^t_0 \leftarrow S^t_0 \lll b'_2.\\
\textrm{Round 4:} &&
S^{t+1}_3 &\leftarrow ( S^t_3 \oplus (S^t_4 \cdot S^t_0) \oplus S^t_1 \oplus m_i ) \lll_w b_3 &
S^t_1 \leftarrow S^t_1 \lll b'_3.\\
\textrm{Round 5:} &&
S^{t+1}_4 &\leftarrow ( S^t_4 \oplus (S^t_0 \cdot S^t_1) \oplus S^t_2 \oplus m_i ) \lll_w b_4 &
S^t_2 \leftarrow S^t_2 \lll b'_4.
\end{align*}

\subsubsection{Initialization.}
The initialization of \cipher{MORUS640} consists of loading a 128-bit key $K_{128}$ and a 128-bit nonce $IV_{128}$ into the state, and running the {\tt StateUpdate} for 16 steps. The key and nonce are loaded into the state as follows:
\begin{align*}
S^{-16}_0 = \textrm{IV}_{128}, &&
S^{-16}_1 = K_{128}, &&
S^{-16}_2 = 1^{128}, &&
S^{-16}_3 = const_0, &&
S^{-16}_4 = const_1.
\end{align*}
Then the internal state is updated 16 times by  ${\tt StateUpdate}(S^t,0)$ for $t=-16,-15,\ldots,-1$. Finally, the key is xored to the state again as $S^0_1 \leftarrow S^0_1 \oplus K_{128}$.

The initialization of \cipher{MORUS1280} is slightly different from that of \cipher{MORUS640} due to the different register size and the two possible key size:
\begin{itemize}
  \item[-] When the key size is 128 bits, $K = K_{128} \|K_{128}$
  \item[-] When the key size is 256 bits, $K = K_{256}$
\end{itemize}
The state is initialized as
\begin{align*}
S^{-16}_0 &= \textrm{IV}_{128} \| 0^{128}, &
S^{-16}_1 &= K, &
S^{-16}_2 = 1^{256}, \\
S^{-16}_3 &= 0^{256}, &
S^{-16}_4 &= const_0\|const_1.
\end{align*}
After updating the state 16 times, the state is updated by $S^0_1 \leftarrow S^0_1 \oplus K$.


\subsubsection{Associated Data Processing.}
After the initialization, the associated data $A$ is processed. For the padding, if the last associated data block is not a full block, use `0' bits to pad it to 128 bits and 256 bits for \cipher{MORUS640} and \cipher{MORUS1280}, respectively, and the padded full block is used to update the state. Note that if the length of $A$ denoted by `$adlen$' is 0, the associated data processing is skipped.

Then, state is updated by $S^{t+1} \leftarrow {\tt StateUpdate}(S^t, A^t)$ for $t=0,1,\ldots,\ell$ where $\ell = \lceil \frac{adlen}{128} \rceil -1$ and $\ell = \lceil \frac{adlen}{256} \rceil -1$ for \cipher{MORUS640} and \cipher{MORUS1280}, respectively.

\subsubsection{Encryption.}
At each step of the encryption, a 16-byte (resp. 32-byte) message block $M_i$ is used to update the state, and $M_t$ is encrypted to $C_t$ in \cipher{MORUS640} (resp. \cipher{MORUS1280}).

If the last message block is not a full block, use `0' bits to pad it to 128 and 256 bits for \cipher{MORUS640} and \cipher{MORUS1280}, respectively, and the padded full block is used to update the state. But only the partial block is encrypted. Note that if the message length denoted by `$msglen$' is 0, encryption is skipped.

In \cipher{MORUS640}, Let $u = \lceil \frac{adlen}{128} \rceil$ and $v = \lceil \frac{msglen}{128} \rceil$. The following is performed for $t=0, 1, \ldots, v-1$;
\begin{align*}
C^t &\leftarrow M^t \oplus S^{u+t}_0 \oplus (S^{u+t}_1 \lll 96) \oplus (S^{u+t}_2 \cdot S^{u+t}_3),\\
S^{u+t+1} &\leftarrow {\tt StateUpdate}(S^{u+t},M^t).
\end{align*}

For \cipher{MORUS1280}, $u = \lceil \frac{adlen}{256} \rceil$ and $v = \lceil \frac{msglen}{256} \rceil$. The equation to compute ciphertext block $C^t$ is $C^t \leftarrow M^t \oplus S^{u+t}_0 \oplus (S^{u+t}_1 \lll 192) \oplus (S^{u+t}_2 \cdot S^{u+t}_3)$.

\subsubsection{Finalization.}
The finalization generates the authentication tag $T$ using 10 more steps. We only discuss the case that $T$ is not truncated. The associated data length and the message length are used to update the state as follows.
\begin{enumerate}
\item $tmp \leftarrow adlen\|msglen$ for \cipher{MORUS640} and $tmp \leftarrow adlen\|msglen\|0^{128}$ for \cipher{MORUS1280}, where $adlen$ and $msglen$ are represented as 64-bit integers.
\item $S^{u+v}_4 \leftarrow S^{u+v}_4 \oplus S^{u+v}_0.$
\item For $t = u+v, u+v+1, \ldots, u+v+9,$ compute
%\begin{equation*}
$S^{t+1} \leftarrow {\tt StateUpdate} (S^t, tmp)$.
%\end{equation*}
\item For \cipher{MORUS640}, $T = S^{u+v+10}_0 \oplus (S^{u+v+10}_1 \lll 96) \oplus ( S^{u+v+10}_2 \cdot S^{u+v+10}_3)$. For \cipher{MORUS1280}, $S^{u+v+10}_0 \oplus (S^{u+v+10}_1 \lll 192) \oplus ( S^{u+v+10}_2 \cdot S^{u+v+10}_3)$ is computed and the least significant 128 bits are produced as a tag $T$.
\end{enumerate}

\subsubsection{Security.}
When the tag size is 128 bits, integrity is claimed up to 128-bits and confidentiality is claimed up to the number of bits of the key.
\begin{table}[!htb]
\centering
\caption{Security Goals of MORUS.}
\begin{tabular}{ccc}\hline
                        & Confidentiality (bits) & Integrity (bits) \\ \hline
\cipher{MORUS640}-128   & 128                    & 128              \\
\cipher{MORUS1280}-128  & 128                    & 128              \\
\cipher{MORUS1280}-256  & 256                    & 128              \\ \hline
\end{tabular}
\end{table}

\subsection{Notation}
\label{subsec/Notation}

We define the \emph{bias} of an event $E$ as:
\[
\bias(E) \eqdef 2\Pr(E)-1.
\]
Note that the bias is sometimes defined as half the above value in the literature. We also define the \emph{weight} of an event as:
\[
\weight(E) \eqdef -\log|\bias(E)|
\]
where $\log()$ denotes logarithm in base 2. By the piling-up lemma, the bias (resp. weight) of an XOR of independent variables is equal to the product (resp. sum) of their individual biases (resp. weights).

We will also use the following notation, where an \emph{encryption step} refers to one call to the \StateUpdate{} function:\\
\centerline{
\def\arraystretch{1.25}
\begin{tabular}{lcl}
$C^t$ &:& the ciphertext block output during the $t$-th encryption step.\\
$C^t_j$ &:& the $j$-th bit of $C^t$, with $C^t_0$ being the rightmost bit.\\
$S^t_i$ &:& the $i$-th register at the beginning of $t$-th encryption step.\\
$S^t_{i,j}$ &:& the $j$-th bit of $S^t_i$, with $S^t_{i,0}$ being the rightmost bit.
\end{tabular}
}
In the above notation, bit positions are always taken modulo the register size, i.e. 128 for \cipher{MORUS640} and 256 for \cipher{MORUS1280}.

In the remainder, the $0$-th encryption step will denote the encryption step where our linear trail starts. Any encryption step could be chosen for that purpose, as long as at least four more encryption steps follow. In particular the $0$-th encryption step from the perspective of the trail does not have to be the first encryption step after initialization.

%Finally, let $x$ denote a register. Recall that registers of \cipher{MORUS} are composed of four words. We now define register-wise and word-wise rotations (denoted by \texttt{<<<} and \texttt{Rotl\_xxx\_yy} respectively in the \cipher{MORUS} design document):\\
%\centerline{
%\def\arraystretch{1.25}
%\begin{tabular}{lcl}
%$x \rotl y$ &:& circular shift of $x$ by $y$ bits to the left.\\
%$x \rotlxy y$ &:& circular shift of each word within $x$ by $y$ bits to the left.\\
%\end{tabular}
%}
%
%The $b_i$'s denote rotation constants, whose value depends on which version of \cipher{MORUS} is considered. Throughout, $w$ denotes the  word size, i.e. $w=32$ for \cipher{MORUS640} and $w=64$ for \cipher{MORUS1280}.
